2025. 5. 14. 오후 2:25 녹음읽기전용
스크립트


setting
곱셈
다항식
더하기
복호
서버
암호
제곱
틸다

00:42
그러면 일단 여러분들이 암호화 복호화는 이제 잘 하니까 그 일단 다항식 곱셈을 좀 더 단순한 형태로 바꿉시다 다항식 곱셈을 어떻게 바꾸냐면요 다항식 a랑 s랑 곱할 때 지금은 얘네를 다 퓨리 트랜스폼을 하고 퓨리 트랜스폼을 한 다음에 인버스 퓨리에 트랜스폼 하는 식으로 했었잖아요. 근데 그렇게 하지 말고 그냥 컨볼루션을 그냥 계산하죠. 무슨 말인지 알겠죠. 그래서 컨볼루션을 그냥 계산하면 여기 다항식 a라는 녀석은 ai에 xi에 summation 이렇게 생긴 놈일 거고요. 혹시 제가 얘기하는 게 중간에 이해 안 가면 끊으세요. 그렇죠. 그 고개를 계속 끄덕거리고 있으면 저는 이해한 줄 알고 넘어가니까 잘 안 보이지 않아요. 이거 덮고 잠깐 얘기를 해봅시다 끊어 끊으세요. 진짜로 네 바로바로 끊으세요.

01:39
그 다음에 s는 summation of si 곱하기 xi일 것 같아요. 그래서 a 곱하기 s를 그냥 그대로 곱셈을 하게 되면 얘는 어떻게 될 거냐면 이 녀석의 0번째에 해당하는 거는 a0 곱하기 s0도 있을 거고요. 그다음 1번째에 해당하는 거는 a1 곱하기 s0 더하기 a0 더하기 아 곱하기 s1 이런 애가 있을 거고요. 그래서 여기에 곱하기 x의 1승이 되겠죠. 얘는 곱하기 x에 0승이 될 거고요. 그다음에 2에 해당하는 건 a2s0 a1 s1 a2 아 a0 s2 x제곱 이런 식으로 있을 거예요.

02:30
이게 n까지 n 마이너스 1까지 있고 0부터 n 마이너스 1까지 있으니까 얘를 쭉쭉 계산을 하면은 제일 마지막에 나오는 거는 a의 n 마이너스 1 곱하기 x에 2의 n 마이너스 2 요런 애까지 나올 거예요. 네 이런 식으로 다항식곱을 계산할 수 있거든요. 이거 계산하는 거는 그냥 loop 두 개 쓰면 되죠. i loop j loop 해가지고 그냥 다 더하고 이렇게 해가지고 집어넣으면 되죠. 그래서 느리지만 그래도 동작은 할 거거든요. 근데 이때 얘네들이 위치하는 공간이 어디냐면은 그 정수 공간에 있을 건데 이게 gq상에 있을 거거든요. 이 gq라는 애는 뭐냐면은 모든 숫자를 모드 큐를 하는 거예요. 그러니까 큐로 나눈 나머지만 쓰는 거예요.

03:25
그래서 예를 들어서 3 곱하기 5 모드 7 이거는 그러니까 3이 g7상에 있고 그 다음에 5가 또 g의 7상에 있다고 해볼게요 그러면 이거 두 개 곱은 어떻게 되냐면요 15죠 근데 이거는 뭐랑 똑같냐면 8이랑 똑같고, 이건 1이랑 똑같다 그래서 여기에서 모든 곱셈 덧셈 계산한 다음에 이거를 한번 해주세요. q로 나눈 나머지를 그리고 이때 q는 2에 120승 뭐 이런 애를 한번 써봅시다 근데 그 variable로 설정할 수 있게 내놓으세요. 그리고 빅인트를 써서 알겠죠. 네 그래서 이거를 이렇게 하는 이유는 빅인트를 쓸려고 하는 거예요. 그래서 풀어서 쓰는 거예요.

04:15
우리 freetrancon 못쓰니까 빅인트에서 자 이거 됐고 근데 이 곱셈이 이 차원이 차수가 2의 n승 마이너스 이런 애가 나오면 안 되거든요. 이거 얘기했었나요? 얘가 이제 x의 n승 마이너스 1 더하기 1 요것만 쓴다는 거 얘기했었나요? 혹시 했던 것 같아요. 자 그래서 얘로 나눈 나머지만 또 쓸 거거든요. 다항식도 근데 이거로 나눈 나머지라는 뜻은 뭐냐면 x의 n승이 마이너스 1이랑 똑같다는 거예요. 왜냐면은 xn승 더하기 1은 0이니까. 자기 자신으로 나누면 나머지가 0이잖아요. 언제나 그래서 요거랑 똑같거든요. 그래서 얘를 다시 수정을 해주면 어떻게 되냐면 요거는 뭐랑 같냐면요 얘를 다시 풀어서 쓰면 x의 n승 곱하기 x의 n승 빼기 2가 되죠.

05:14
근데 얘가 마이너스 1이랑 똑같잖아요. 그래서 마이너스 x의 n승 빼기 2가 돼요. 그러면 여기 있는 애들 x에 x의 n승 마이너스 1까지 있는 애들 다 살려놓고 여기 x에 n승 있는 애들은 얘는 또 마이너스 1이랑 똑같아 그래서 여기 있는 값을 여기에서 여기에다가 빼주면 되겠죠. 마이너스 해갖고 더해주면 되고 얘도 마이너스에서 더해주고 마이너스에서 더해주고 쭉쭉 하면은 이것도 결국에는 이제 최대차수가 x의 n승 마이너스 1 안으로 나오게 만들 수 있겠죠. 이게 완전한 다항식 곱셈 알겠죠. 이게 당시 곱셈입니다. 네, 그러면 이렇게 일단 암호화 복호화를 바꿔보면 되고요.

06:14
그다음에 우리가 해야 할 게 무엇이냐면 곱셈입니다. 곱셈은 이제 서버에서 하는 거예요. 곱셈은 서버에서 하는 거예요. 뺄셈이랑 곱셈 그죠 왜냐면, 내가 가지고 있는 feature랑 내가 받은 feature랑 비교할 거니까 빼서 유클리드 거리 구할 거죠. 그래서 내가 가지고 있는 데이터베이스들이 막 여러 개가 있는데, 거기서 하나하나 다 뺄 거예요. 그래서 여기서 뺀 놈을 하나 뭐 b 바 a 바라고 합시다. c0 c1이라고 했었나요? 우리가 노테이션 그전에 어떻게 했었죠. c1 시트로 했었어요. 자 그럼 여기서 c1 c2 이렇게 해볼게요 여기서 빼온 애를 c1 c2 바 바 이렇게 하고요.

AI 요점 정리
1.
복호화와 곱셈 원리 이해
1-1.
복호화 원리와 복호화
클라이언트에서 라이브러리를 사용할 수 없으면 복호화가 힘들어짐
생성된 암호문을 다른 형태로 변환해서 서버로 전송하는 것이 필요함
암호화와 복호화를 잘 수행하면 다항식 곱셈을 단순화할 수 있음
컨볼루션을 이용한 다항식 계산이 필요함
1-2.
다항식 곱셈 원리와 복호화
다항식곱셈은 두 개의 다항식을 더한 후, 그 값을 최대차수로 나눔
최대차수는 항상 일정하며, 그 값이 가진 의미를 설명해야 함
복호화는 곱셈에서 뺄셈으로 이어지며, 이 때의 암호는 빼기 했을 때와 마찬가지로 더함
복호화와 뺄셈에 대한 원리를 이해하면 복호화와 곱셈을 쉽게 이해할 수 있음
1-3.
암호화와 곱셈의 원리
복호화는 앞서 빼기 했을 때와 마찬가지로 더함
곱셈은 본래의 수식을 기반으로 역연산을 통해 이루어짐
뺄셈과 곱셈은 각각 다항식의 위치를 바꾸고 제곱하는 과정으로 이루어짐
이 과정을 이해하면 복호화와 곱셈에 대한 이해가 용이함
2.
수학 원리에 기반한 얼굴 인식 시스템
2-1.
중학교 수학 원리의 적용
중학교 수학 원리를 이용하여 얼굴 인식 시스템을 설명함
중학교 2학년 때 배우는 수학 원리들이 얼굴 인식 시스템에 적용됨
수학 원리에 따른 얼굴 인식이 클라이언트에게 반환되며, 이를 서버에서 처리함
이때, 각각의 얼굴을 2차식으로 표현하여 인식함
비밀 키를 사용하여 데이터의 약간의 함정을 넣어 문제를 야기함
2-2.
얼굴 인식 시스템의 작동
각각의 얼굴을 복호화하여 측정 값으로 사용함
서버에서 클라이언트에게 반환된 값을 이용하여 3개의 튜플을 생성함
각 튜플은 각각의 얼굴을 기반으로 계산하여 측정 값이 0에 가까울수록 얼굴을 식별함
이 과정에서 복호화를 통해 0에 가까운지 아닌지 판별함
이때, 서버에서 정보를 안 주면 안 된다는 점을 강조함
2-3.
얼굴 인식 시스템의 효율성
서버에서 처리 과정을 관리하며, 서버와 클라이언트 모두에서 이 시스템의 효율성을 향상시킴
각 얼굴에 대해 복호화 과정을 거쳐 측정 값을 얻음
서버에서 클라이언트에게 반환된 값을 이용하여 얼굴을 식별함
이 시스템은 악의적인 사용자가 얼굴 데이터를 0으로 바꿔 제곱한 후 0을 빼서 제곱을 하는 것을 방지함
이를 통해 데이터의 노출을 최소화하며, 데이터 보안을 강화함
00:00



1x
21:42
사실 클라이언트단에서 라이브러리를 쓸 수가 없으면 이게 아이오가 되게 힘들어지는 것 같아요. 그러니까 이 라이브러리에서 생성한 암호문을 뭔가 제이슨이나 뭐 다른 파일 형태로 변환해 가지고 보내서 다른 서버에서 읽고 오고 이런 건 되는데 다른 데에서 생성한 애를 얘 포맷으로 만드는 거를 공부하는 게 오히려 더 힘들 것 같아요. 무슨 말인지 알겠죠. 그래서 이거를 그냥 통짜로 만들면 오히려 쉬울 것 같거든요. 제 생각에는 네 그래서 아마 그렇게 해야 될 것 같은데요. 그러면 일단 여러분들이 암호화 복호화는 이제 잘 하니까 그 일단 다항식 곱셈을 좀 더 단순한 형태로 바꿉시다 다항식 곱셈을 어떻게 바꾸냐면요 다항식 a랑 s랑 곱할 때 지금은 얘네를 다 퓨리 트랜스폼을 하고 퓨리 트랜스폼을 한 다음에 인버스 퓨리에 트랜스폼 하는 식으로 했었잖아요. 근데 그렇게 하지 말고 그냥 컨볼루션을 그냥 계산하죠. 무슨 말인지 알겠죠. 그래서 컨볼루션을 그냥 계산하면 여기 다항식 a라는 녀석은 ai에 xi에 summation 이렇게 생긴 놈일 거고요. 혹시 제가 얘기하는 게 중간에 이해 안 가면 끊으세요. 그렇죠. 그 고개를 계속 끄덕거리고 있으면 저는 이해한 줄 알고 넘어가니까 잘 안 보이지 않아요. 이거 덮고 잠깐 얘기를 해봅시다 끊어 끊으세요. 진짜로 네 바로바로 끊으세요. 그 다음에 s는 summation of si 곱하기 xi일 것 같아요. 그래서 a 곱하기 s를 그냥 그대로 곱셈을 하게 되면 얘는 어떻게 될 거냐면 이 녀석의 0번째에 해당하는 거는 a0 곱하기 s0도 있을 거고요. 그다음 1번째에 해당하는 거는 a1 곱하기 s0 더하기 a0 더하기 아 곱하기 s1 이런 애가 있을 거고요. 그래서 여기에 곱하기 x의 1승이 되겠죠. 얘는 곱하기 x에 0승이 될 거고요. 그다음에 2에 해당하는 건 a2s0 a1 s1 a2 아 a0 s2 x제곱 이런 식으로 있을 거예요. 이게 n까지 n 마이너스 1까지 있고 0부터 n 마이너스 1까지 있으니까 얘를 쭉쭉 계산을 하면은 제일 마지막에 나오는 거는 a의 n 마이너스 1 곱하기 x에 2의 n 마이너스 2 요런 애까지 나올 거예요. 네 이런 식으로 다항식곱을 계산할 수 있거든요. 이거 계산하는 거는 그냥 loop 두 개 쓰면 되죠. i loop j loop 해가지고 그냥 다 더하고 이렇게 해가지고 집어넣으면 되죠. 그래서 느리지만 그래도 동작은 할 거거든요. 근데 이때 얘네들이 위치하는 공간이 어디냐면은 그 정수 공간에 있을 건데 이게 gq상에 있을 거거든요. 이 gq라는 애는 뭐냐면은 모든 숫자를 모드 큐를 하는 거예요. 그러니까 큐로 나눈 나머지만 쓰는 거예요. 그래서 예를 들어서 3 곱하기 5 모드 7 이거는 그러니까 3이 g7상에 있고 그 다음에 5가 또 g의 7상에 있다고 해볼게요 그러면 이거 두 개 곱은 어떻게 되냐면요 15죠 근데 이거는 뭐랑 똑같냐면 8이랑 똑같고, 이건 1이랑 똑같다 그래서 여기에서 모든 곱셈 덧셈 계산한 다음에 이거를 한번 해주세요. q로 나눈 나머지를 그리고 이때 q는 2에 120승 뭐 이런 애를 한번 써봅시다 근데 그 variable로 설정할 수 있게 내놓으세요. 그리고 빅인트를 써서 알겠죠. 네 그래서 이거를 이렇게 하는 이유는 빅인트를 쓸려고 하는 거예요. 그래서 풀어서 쓰는 거예요. 우리 freetrancon 못쓰니까 빅인트에서 자 이거 됐고 근데 이 곱셈이 이 차원이 차수가 2의 n승 마이너스 이런 애가 나오면 안 되거든요. 이거 얘기했었나요? 얘가 이제 x의 n승 마이너스 1 더하기 1 요것만 쓴다는 거 얘기했었나요? 혹시 했던 것 같아요. 자 그래서 얘로 나눈 나머지만 또 쓸 거거든요. 다항식도 근데 이거로 나눈 나머지라는 뜻은 뭐냐면 x의 n승이 마이너스 1이랑 똑같다는 거예요. 왜냐면은 xn승 더하기 1은 0이니까. 자기 자신으로 나누면 나머지가 0이잖아요. 언제나 그래서 요거랑 똑같거든요. 그래서 얘를 다시 수정을 해주면 어떻게 되냐면 요거는 뭐랑 같냐면요 얘를 다시 풀어서 쓰면 x의 n승 곱하기 x의 n승 빼기 2가 되죠. 근데 얘가 마이너스 1이랑 똑같잖아요. 그래서 마이너스 x의 n승 빼기 2가 돼요. 그러면 여기 있는 애들 x에 x의 n승 마이너스 1까지 있는 애들 다 살려놓고 여기 x에 n승 있는 애들은 얘는 또 마이너스 1이랑 똑같아 그래서 여기 있는 값을 여기에서 여기에다가 빼주면 되겠죠. 마이너스 해갖고 더해주면 되고 얘도 마이너스에서 더해주고 마이너스에서 더해주고 쭉쭉 하면은 이것도 결국에는 이제 최대차수가 x의 n승 마이너스 1 안으로 나오게 만들 수 있겠죠. 이게 완전한 다항식 곱셈 알겠죠. 이게 당시 곱셈입니다. 네, 그러면 이렇게 일단 암호화 복호화를 바꿔보면 되고요. 그다음에 우리가 해야 할 게 무엇이냐면 곱셈입니다. 곱셈은 이제 서버에서 하는 거예요. 곱셈은 서버에서 하는 거예요. 뺄셈이랑 곱셈 그죠 왜냐면, 내가 가지고 있는 feature랑 내가 받은 feature랑 비교할 거니까 빼서 유클리드 거리 구할 거죠. 그래서 내가 가지고 있는 데이터베이스들이 막 여러 개가 있는데, 거기서 하나하나 다 뺄 거예요. 그래서 여기서 뺀 놈을 하나 뭐 b 바 a 바라고 합시다. c0 c1이라고 했었나요? 우리가 노테이션 그전에 어떻게 했었죠. c1 시트로 했었어요. 자 그럼 여기서 c1 c2 이렇게 해볼게요 여기서 빼온 애를 c1 c2 바 바 이렇게 하고요. 데이터베이스에서 빼온 애를 그다음에 서버에서 얘가 이렇게 해가지고 열심히 만들어서 돌려준 거를 c1 c2라고 해볼게요 그래서 얘네들 사이에 뺄셈은 어떻게 하냐면요 c1 빼기 c 아 c1 바 c2 빼기 c2 바 하면은 얘가 뺄셈에 대한 암호입니다. 그래서 얘가 사실은 m을 암호화하고 있는 녀석이고 얘가 뭔가 mba를 암호화하고 있는 녀석이면 얘는 m 빼기 mba를 암호화하고 있는 그런 암호문이 됩니다. 이 원리에 대해서 설명했었죠. 안 했었나요? 이 원리에 대해서 얘기를 하자면은 일단 이 원리는 넘어가도 되는데 원리를 알고 있어야지 그 코드 짤 때 그냥 아 뭐하는 거야. 이러지 않을 테니까. 원리가 어떻게 되냐면은 얘 복호화는 c1 더하기 c2 곱하기 s가 음 더하기 2가 되는 그런 원리였어요. 음 그렇군요. 네, 그러면은 c1 요놈을 복호화하면 어떻게 되냐면요 c1 빼기 c1 파 곱하기 아 더하기 c1 빼기 c2 빼기 c2 파 곱하기 s가 되죠. 그러면 이거 풀어서 쓰면 얘는 c1 빼기 c2 곱하기 s 아 더하기구나 더하기 s 그 다음에 더하기 아 빼기 c1 파 더하기 c1 파 곱하기 s 이렇게 되는 거야. 여기서 그냥 단순히 여기 분배한 다음에 위치만 바꾼 거예요. 근데 얘가 뭐였어요. 얘가 m이죠. 얘가 m 더하기 에러죠 그래서 빼기 mba+error 이거라서 얘는 대충 m 빼기 m바 이렇게 됩니다. 어 그래서 이 원리로 이제 뺄셈이 되는 거예요. 끝이에요. 음 자 그래서 1번 빼기 자 이 빼기를 할 때도 항상 뺀 다음에 모두 귤을 항상 해주세요. 220승 알겠죠. 그 다음에 이제 곱셈을 해줘야 돼요. 곱셈은 어떻게 하냐면요 근데 우리는 사실 곱셈은 안 하고 나 자신을 제곱하는 것만 할 거잖아요. 그죠 결국 이렇게 뺏어 나온 값을 요 값 자체를 제곱을 할 거예요. 그래서 뺏어 나온 값을 뭐 c1의 틸다 c2에 틸다라고 해봅시다 요놈을 제곱을 할 거예요. 그래서 이놈이 이제 어떤 얘는 어떤 암호문이냐면 c1의 틸다 더하기 c2의 틸다 곱하기 s가 m틸다 이 녀석 자 근데 우리가 원하는 거는 m틸다의 제곱인 어떤 암호를 원하는 거잖아요. 그죠 자 그러면 이거를 수식을 역으로 풀어서 써볼게요 이거는 c1의 틸다 더하기 c2에 틸다 곱하기 s의 제곱이겠죠. 얘는 다시 c1에 틸다의 제곱 더하기 c1 c2 틸다틸다2에 곱하기 s 더하기 c2에 틸다 곱하기 s 제곱이고 이거 그냥 요거를 2차식 그냥 풀어 쓴 거예요. a 더하기 bx 제곱한 거 그 중학교 2학년 때 배우는 거 3학년인지 아무튼 그때 배우는 거예요. 그죠 자 요거랑 요거랑 요거 요런 애를 하면 돼요. 근데 여기 s는 비밀키잖아요. 이건 비밀키야 그치 제곱 아 네 아주 좋습니다. 일부러 함정을 넣었어요. 자 에스는 비밀키잖아요. 그래서 얘는 내가 모르는 애거든요. 지금 이걸 서버에서 지금 계산하고 있으니까 이건 몰라요. 그래서 서버에서 해줘야 될 거는 요거 요거 이거 이 3개를 계산을 해주면 돼요. 원해 2에 c1의 제곱 c2의 제곱 c2의 제곱 요걸 계산해 주면 돼요. 자 원래는 얘가 2개짜리 튜플이었잖아요. 이제는 3개짜리 튜플이 돼요. 왜냐하면, 여기에 여기에는 곱하기 1하고 여기는 곱하기 s하고 여기는 곱하기 s제곱 해가지고 다 더하면은 m 딜다의 제곱이 되는 녀석이거든요. 그래서 제곱까지만 해서 돌려주고 싶으면 이거를 구한 다음에 서버에서 클라이언트한테 돌려줍니다. 이거를 구한 다음에 서버에서 클라이언트한테 돌려주게 되면은 어떻게 되느냐 그러면은 얘는 뭔가 c1틸다의 제곱 이거를 다시 뭔가 d1 d2 d3라고 할게요 그러면은 이거 3개 받았으니까 d1 더하기 d2에 s 더하기 d3에 s제곱 했을 때 이게 뭔가 00000이랑 가까우면 그건 내 얼굴 네 이렇게 되는 겁니다. 자 근데 문제가 있어요. 우리가 메시지를 그냥 이렇게 m으로 만든 게 아니고 이 메시지의 정밀도를 위해서 그 라운딩 할 때 날라가는 거를 방지하기 위해서 여기에다가 델타를 곱해줬잖아요. 그러면 m제곱 델타가 나오는 게 아니고 이거를 제곱을 하면 mm²의 델타제곱이 나오거든요. 얘를 복호화했을 때 어차피 0에 가까워서 상관은 없겠지만, 얘가 틸다의 제곱에 델타제곱이 나올 거라 가지고 얘를 나중에 델타제곱으로 다시 나눠줘야지 이게 엠틸다의 제곱이 돼요. 얘가 실제로 0에 가까운지 이렇게 하면 곱셈까지 할 수 있어요. 자 그럼 이거는 이제 서포사이드에서 해야겠죠. 서버사이드에서 해야 되고 근데 이때 여기서 이거 곱셈하고 제곱하는 코드는 이 코드를 재활용해야겠죠. 이 코드를 재활용해야 되니까. 이거는 서브사이드에도 구현을 하고 클램사이드에도 구현을 하고 둘 다 구현을 해줘야 돼요. 그렇게 하면은 여러 개의 얼굴들에 대해서 사실 이거 하면 제곱 거리는 아니거든요. 왜냐하면, 두 개 뺀 다음에 제곱만 한 거잖아요. 그래서 거리는 아니에요. 그죠 그러면 각각의 요소들이 아직 살아있어요. 그래서 얘네를 합을 해줘야 되는데 그것은 그것도 사실 어렵진 않거든요. 그걸 하면 머리가 너무 아프겠지 할까요? 아니면 일단 여기까지 해볼까요? 일단 여기까지 해볼까요? 일단 여기까지 해서 얘가 그 자기 얼굴일 때 진짜 0인 애들이 나오는지 까지만 한번 해봅시다 알겠죠. 일단 여기까지 힌트 그러니까 그 약간 스포일러를 하자면 스포일러를 하자면 그 합을 구하고 싶으면요 여기 c1 c2가 있을 때 c1에서 이제 상수항이 있고 x1의 계수가 있고 x2의 계수가 있고 x3의 계수가 쭉 있잖아요. 상수항 빼고 나머지를 다 빵으로 만들면 합만 남길 수 있어요. 그거는 왜 그러냐면 우리가 메시지를 인코딩 할 때 이거 뒤에 그 뭐죠 뒤에 그 어 리버스 해 가지고 붙였잖아요. 그다음에 퓨리어 트랜스폼 했잖아요. 퓨리어 트랜스포메이션의 첫 번째 항은 모든 항의 합이에요. 네 그래서 그렇거든요. 여기서 나머지 다 빵으로 만들고 첫 번째 항만 살려서 쓰면은 그 전체 합을 볼 수가 있어요. 그래서 사실 우리가 이렇게 해서 이렇게 해서 fpt 한 다음에 뭐 암호화 복호화한 다음에 다시 인버스 fpt 했잖아요. 인버스 fpt 할 필요 없이 그냥 여기 첫 번째 항만 보면 돼요. 알겠죠. 네, 그렇게 하면 되거든요. 그리고 얘는 사실 서버단에서 정보를 안 주면 안 줄수록 좋은 거잖아요. 왜냐하면, 이 연산에 의해서 요 얼굴들에 대한 정보가 어느 정도 들어가긴 들어가잖아요. 내가 준 값이랑 그거 빼 가지고 제곱해서 받은 거니까 진짜 악의적인 유저라면 내 얼굴 데이터를 그냥 0을 다 서버에 전송을 해서 이 결과값을 받으면 실제 얼굴 그 어떤 모든 사람들의 얼굴 값에서 0을 뺀 다음에 제곱한 값을 feature를 얻게 될 거예요. 그거는 심각한 공격이거든요. 데이터베이스 노출이에요. 그래서 그런 걸 하면 안 되기 때문에 사실 0만 있으면 얘는 거리를 구할 수 있잖아요. 그 0이 아니고 coficion 상수 계수만 있으면 그래서 상수 계수 말고 나머지 다 빵으로 만들어서 돌려주면 돼요. 여기 연산할 때 그래서 사실 얘가 해줘야 되는 거는 여기 이 값을 여기 c1에 해당하는 값을 이제 c1이 뭔가 뭐에 더하기 x 1승 더하기 x 제곱 쭉쭉 이렇게 있을 텐데 이걸 다 0으로 0으로 다 바꿔가지고 얘만 남겨서 보내주면 돼요. 그다음에 얘를 계산하면 여기에 이제 어떤 값들이 나올 텐데 여기 뭐시기 더하기 뭐시기에 x 더하기 뭐시기에 x제곱 더하기 쭉쭉 이렇게 나올 텐데 얘는 이제 쓰레기값 제곱 그래서 얘만 사용하면 되는 거예요. 단 근데 여기서 ec1에 있는 요 값들을 다 0으로 날려줄 때 얘네는 건드리면, 안 돼요. 얘네를 건드릴 수는 없어요. 네 일단 그런데요. 그거는 나중에 조금 이따가 해보는 걸로 하고 일단 우리 그러면 라이브러리 의존성 없이 이렇게 해서 제곱해서 돌려주는 거 잘 되는지까지만 한번 해봅시다 그리고 다음 주 월요일에 우리 중간 발표죠 그때 요거가 완성이 돼 있으면은 좋을 것 같아요. 너무 바쁠 수도 있겠지만, 만약에 완성이 안 돼 있다면 일단 요 원리에 대해서 중간 발표 때 설명할 수 있으면 좋을 것 같아요. 이게 어떻게 해서 그렇게 연산이 되는지 그렇습니다. 사실 요거 수식 자체는 진짜 별거 아니거든요. 왜냐하면, 요 연산이 되는 도메인 자체가 우리가 잘 모르는 뭐 정수 모듈로 하고 폴리노미얼 하고 지금 다항식을 수학 숫자처럼 생각을 하고 있잖아요. 실제로 그게 되는 거고, 근데 그런 거에 익숙하지 않아서 그렇지 요거 자체는 그냥 곱셈 덧셈하고 끝이에요. 아무튼 요거를 그러면 구현해 봅시다 라이브러리 의존 없이 갑시다 사실 라이브러리를 잘 만드는 잘 쓰는 게 여러분들의 목표가 아니고 이런 수학적인 원리를 이해하는 게 더 여러분들한테 도움이 될 수도 있어요. 교수님 그 큐 도입하고 이런 것도 똑같이 하는 저것도 혹시 혹시 그 전체 일정이 언제까지 전체 일정이 우리가 기말고사 끝난 그 다음 주 이제 16주차 그때 발표를 하게 될 걸요 논문은 혹시 논문은 논문은 그거보다 조금 더 나중에 내도 될 거예요. 네 제가 한번 알아봐 볼게요 왜냐면, 이게 네 제가 한번 알아봐 네 감사합니다. 네 너무 어려우면 주저하지 말고 제가 그럼 10분 또 있을 거야. 10분 또 있으면 나올 것 같은데, 근데 그거 혹시 내가 잘 몰라서 그런데 어디서 그거를 해보면 되는 거야. 아 내가 내꺼에 깔려고 했더니, 안 깔리더라고. 뭔 짓을 해도 안 깔려고 하니까 아 근데 이렇게 될 것 같았어. 어제 지피처럼 계속 얘기하는데 자기도 나한테 직접 구해달라고 했었어 이거 여기에 이스트 켜가지고 그럼 이거를 파이썬 환경으로 다 썼거든. 파이썬 없애고 10% 깔아가지고, 만들어서 여기서 돌리는데 이런 식으로 씨뿔뿔 또 깔아가지고, 여기서 다음에 혹시 보내면 되지 않을까? 그다음에 나중에 만두환 다 되면 또 백그라운드 돌려가지고 계속 틀어놓으면 되니까. 그래서 아마 그거 해볼 때 이시트 들어간 다음에 어 맞아 이 가상환경 이런 거 응 여기에서 이제 그 우리가 환경 설치 막 필요한 거 그런 거 지플 뿌리나 이런 거 다운 받아가지고, 너 얘 좀 녹음하는 사람 없지 아 나 하고 있어
